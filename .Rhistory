cor0.5=c()
for (j in 1:4) {
r=c()
for (i in 1:2000) {
q12=0.5*(1-par[j]*par[j])/sqrt((1-par[j]^2)*(1-par[j]^2))
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,q12),c(q12,1)))
at = arima.sim(list(ar=par[j]),n = 200,innov =f[,1])
bt = arima.sim(list(ar=par[j]),n = 200,innov =f[,2])
r=c(r,test(at,bt,1,1,0.05)[1])
}
cor0.5=c(cor0.5,mean(r))
}
#===================================
gc()
#correlation 0.9
par=c(0,0.1,0.5,0.9)
cor0.9=c()
for (j in 1:4) {
r=c()
for (i in 1:2000) {
q12=0.9*(1-par[j]*par[j])/sqrt((1-par[j]^2)*(1-par[j]^2))
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,q12),c(q12,1)))
at = arima.sim(list(ar=par[j]),n = 200,innov =f[,1])
bt = arima.sim(list(ar=par[j]),n = 200,innov =f[,2])
r=c(r,test(at,bt,1,1,0.05)[1])
}
cor0.9=c(cor0.9,mean(r))
}
#=========AR2====================
gc()
# AR2 cor 0:
ar2cor0=c()
r=c()
for (i in 1:2000) {
at = arima.sim(list(ar=c(0.6,0.2)),n = 200)
bt = arima.sim(list(ar=c(0.6,0.2)),n = 200)
r=c(r,test(at,bt,2,2,0.05)[1])
}
ar2cor0=c(mean(r))
#================================
gc()
# AR2 correlation 0.5
ar2cor0.5=c()
r=c()
for (i in 1:2000) {
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,0.5),c(0.5,1)))
at = arima.sim(list(ar=c(0.6,0.2)),n = 200,innov = f[,1])
bt = arima.sim(list(ar=c(0.6,0.2)),n = 200,innov = f[,2])
r=c(r,test(at,bt,2,2,0.05)[1])
}
ar2cor0.5=c(mean(r))
#===============================
gc()
# AR2 correlation 0.9
ar2cor0.9=c()
r=c()
for (i in 1:2000) {
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,0.9),c(0.9,1)))
at = arima.sim(list(ar=c(0.6,0.2)),n = 200,innov = f[,1])
bt = arima.sim(list(ar=c(0.6,0.2)),n = 200,innov = f[,2])
r=c(r,test(at,bt,2,2,0.05)[1])
}
ar2cor0.9=c(mean(r))
overall= data.frame("cor 0"=c("======",cor0,"======",ar2cor0),
"cor 5"=c("======",cor0.5,"======",ar2cor0.5),
"cor 9"=c("======",cor0.9,"======",ar2cor0.9),
row.names =c(" ==========  ",
"     Q1=0    ",
"    Q1=0.1   ",
"    Q1=0.5   ",
"    Q1=0.9   ",
" =========== ",
"Q1=0.6 Q2=0.2"))
overall
# power of the test:
require("MASS")
#====================================
gc()
# 0 correlation:
par1=c(0,0.1,0.2,0.3,0.4,0.5)
pcor0=c()
for (j in 1:6) {
r=c()
for (i in 1:2000) {
at = arima.sim(list(),n = 200)
bt = arima.sim(list(ar=c(par1[j])),n = 200)
r=c(r,test(at,bt,1,1,0.05)[1])
}
pcor0=c(pcor0,mean(r))
}
#====================================
gc()
#correlation 0.5
pcor0.5=c()
for (j in 1:6) {
r=c()
for (i in 1:2000) {
q12=0.5*(1-par1[j]*par1[j])/sqrt((1-par1[j]^2)*(1-par1[j]^2))
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,q12),c(q12,1)))
at = arima.sim(list(),n = 200,innov =f[,1])
bt = arima.sim(list(ar=par1[j]),n = 200,innov =f[,2])
r=c(r,test(at,bt,1,1,0.05)[1])
}
pcor0.5=c(pcor0.5,mean(r))
}
#====================================
gc()
#correlation 0.9
pcor0.9=c()
for (j in 1:6) {
r=c()
for (i in 1:2000) {
q12=0.9*(1-par1[j]*par1[j])/sqrt((1-par1[j]^2)*(1-par1[j]^2))
f=mvrnorm(200,mu=c(0,0),Sigma=cbind(c(1,q12),c(q12,1)))
at = arima.sim(list(),n = 200,innov =f[,1])
bt = arima.sim(list(ar=par1[j]),n = 200,innov =f[,2])
r=c(r,test(at,bt,1,1,0.05)[1])
}
pcor0.9=c(pcor0.9,mean(r))
}
#====================================
power= data.frame("cor 0"=c("======",pcor0),
"cor 5"=c("======",pcor0.5),
"cor 9"=c("======",pcor0.9),
row.names =c(" ==========  ",
"     Q1=0    ",
"    Q1=0.1   ",
"    Q1=0.2   ",
"    Q1=0.3   ",
"    Q1=0.4   ",
"    Q1=0.5   "))
power
overall
cluster(39,m_test,0.01)
require('forecast')
order=c()
for (i in 2:250) {
order = c(order,auto.arima(diff(ts(df[i],12)),seasonal = F,max.q = 0)$arma[1])
}
for (i in 1:249) {
if (order[i]==0) {
order[i]=1
}
}
m_test_sonelgaz=matrix(0,nrow = 249,ncol = 249)
for (i in 1:248) {
for (j in (i+1):249) {
m_test_sonelgaz[j,i]=test(diff(ts(df[i+1]),12),diff(ts(df[j+1]),12),order[i],order[j],0.01)[2]
m_test_sonelgaz[i,j]=m_test_sonelgaz[j,i]
}
}
auto.arima(diff(ts(df[3],start = c(2000,1),frequency =12)),max.q = 0)$arma[1]
auto.arima(diff(ts(df[3],start = c(2000,1),frequency =12)),max.q = 0)
auto.arima(diff(ts(df[3],start = c(2000,1),frequency =12)))
install.packages('TSclust')
diss.AR.MAH(series[1,], series[2,], dependence=FALSE, permissive=TRUE)
require('TSclust')
diss.AR.MAH(series[1,], series[2,], dependence=FALSE, permissive=TRUE)
test(series[1,],series[2,],1,1,0.05)[2]
test(series[1,],series[2,],1,1,0.05)[3]
test(series[1,],series[2,],1,2,0.05)[3]
test(series[1,],series[2,],1,3,0.05)[3]
test(series[1,],series[2,],1,4,0.05)[3]
test(series[1,],series[2,],1,10,0.05)[3]
test(series[1,],series[2,],1,6,0.05)[3]
test(series[1,],series[2,],1,5,0.05)[3]
test(series[1,],series[2,],1,4,0.05)[3]
diss.AR.MAH(series[1,], series[2,], dependence=FALSE, permissive=F)
diss.AR.MAH(series[1,], series[2,], dependence= T, permissive= F)
diss.AR.MAH(series[1,], series[2,], dependence= T, permissive= T)
test(series[1,],series[2,],1,1,0.05)[3]
test(series[1,],series[2,],1,1,0.05)[2]
cluster(39,m_test,0.01)
series=matrix(0,nrow = 40,ncol = 200)
for (i in 1:10) {
gc()
series[i,]=arima.sim(list(),n = 200)
series[10+i,]=arima.sim(list(ar=c(0.5)),n = 200)
series[20+i,]=arima.sim(list(ma=c(0.9)),n = 200)
series[30+i,]=arima.sim(list(ar=c(-0.6),ma=c(0.3)),n = 200)
}
series=matrix(0,nrow = 40,ncol = 200)
for (i in 1:10) {
gc()
series[i,]=arima.sim(list(),n = 200)
series[10+i,]=arima.sim(list(ar=c(0.5)),n = 200)
series[20+i,]=arima.sim(list(ar=c(0.9)),n = 200)
series[30+i,]=arima.sim(list(ar=c(-0.6),ma=c(0.3)),n = 200)
}
m_test=matrix(0,nrow = 40,ncol = 40)
for (i in 1:39) {
for (j in (i+1):40) {
m_test[j,i]=test(series[i,],series[j,],1,1,0.01)[2]
m_test[i,j]=m_test[j,i]
}
}
cluster(39,m_test,0.01)
series=matrix(0,nrow = 40,ncol = 200)
for (i in 1:10) {
gc()
series[i,]=arima.sim(list(),n = 200)
series[10+i,]=arima.sim(list(ar=c(0.5)),n = 200)
series[20+i,]=arima.sim(list(ma=c(0.9)),n = 200)
series[30+i,]=arima.sim(list(ar=c(-0.6),ma=c(0.3)),n = 200)
}
m_test=matrix(0,nrow = 40,ncol = 40)
for (i in 1:39) {
for (j in (i+1):40) {
m_test[j,i]=test(series[i,],series[j,],1,1,0.01)[2]
m_test[i,j]=m_test[j,i]
}
}
cluster(39,m_test,0.01)
library(readxl)
require(stats)
Classeur1 = read_excel("Classeur1.xlsx",
sheet = "for R")
df = data.frame(Classeur1)
require('forecast')
order=c()
for (i in 2:250) {
order = c(order,auto.arima(diff(ts(df[i],12)),seasonal = F,max.q = 0)$arma[1])
}
order
auto.arima(diff(ts(df[4],12)),seasonal = F,max.q = 0)
auto.arima(diff(ts(df[4],12)),seasonal = F,max.q = 0,trace = T)
for (i in 1:249) {
if (order[i]==0) {
order[i]=1
}
}
m_test_sonelgaz=matrix(0,nrow = 249,ncol = 249)
for (i in 1:248) {
for (j in (i+1):249) {
m_test_sonelgaz[j,i]=test(diff(ts(df[i+1]),12),diff(ts(df[j+1]),12),order[i],order[j],0.01)[2]
m_test_sonelgaz[i,j]=m_test_sonelgaz[j,i]
}
}
sonel0.05=cluster(248,m_test_sonelgaz,0.05)
sonel0.05
dim(sonel0.05)
sonel0.01=cluster(248,m_test_sonelgaz,0.01)
dim(sonel0.01)
sonel0.01
?sort
head(m_test_sonelgaz)
# ===========================
dist1_sonelgaz = as.dist(m_test_sonelgaz)
head(dist1_sonelgaz)
dist1_sonelgaz
1- matrix(c(1,2,3,4),ncol = 2)
# ===========================
dist1_sonelgaz = as.dist(1-m_test_sonelgaz)
hc_sonelgaz = hclust(dist1_sonelgaz,method = 'complet')
plot(hc_sonelgaz)
# setting the number of  clusters
cut_sonelgaz=cutree(hc_sonelgaz,h = 0.99 )
# coloring the clusters
require('dendextend')
df_cl_sonelgaz <- mutate(df2, cluster = cut_sonelgaz)
Classeur2 = read_excel("Classeur1.xlsx")
df2 = data.frame(Classeur2)
df_cl_sonelgaz <- mutate(df2, cluster = cut_sonelgaz)
count(df_cl_sonelgaz,cluster)
# counting the groupes
require("dplyr")
df_cl_sonelgaz <- mutate(df2, cluster = cut_sonelgaz)
count(df_cl_sonelgaz,cluster)
dim(sonel0.01)
# setting the number of  clusters
cut_sonelgaz=cutree(hc_sonelgaz,h = 0.95 )
df_cl_sonelgaz <- mutate(df2, cluster = cut_sonelgaz)
count(df_cl_sonelgaz,cluster)
df_cl_sonelgaz = mutate(df2, cluster = cut_sonelgaz)
dim(sonel0.05)
col_dend_sonelgaz = color_branches(dend_obj_sonelgaz,k=14,col = c(1,2,3,4,8,7,6,5,1,2,3,4,8,7))
plot(col_dend_sonelgaz)
sonel0.01
for (i in 1:ncol(sonel0.01)) {
sonel0.01[,i]=sort(sonel0.01[,i])
}
sonel0.01
sonel0.01[200:249,]
sonel0.01[190:249,]
sonel0.01[194:249,]
sonel0.01[193:249,]
sonel0.01=sonel0.01[193:249,]
for (i in 1:ncol(sonel0.05)) {
sonel0.05[,i]=sort(sonel0.05[,i])
}
sonel0.05[193:249,]
sonel0.05=sonel0.05[227:249,]
sonel0.05
sonel0.01
library("circlepackeR")
install.packages("circlepackeR")
# ===========================
dist1_sonelgaz = as.dist(1-m_test_sonelgaz)
hc_sonelgaz = hclust(dist1_sonelgaz,method = 'complet')
plot(hc_sonelgaz)
# setting the number of  clusters
cut_sonelgaz=cutree(hc_sonelgaz,k = 14 )
rect.hclust(hc_sonelgaz , k = 14, border = 2:6)
sonel0.01
install.packages("circlepackeR")
install.packages("circlepackeR")
install.packages("circlepackeR")
install.packages("circlepackeR")
install.packages(circlepackeR)
library(circlepackeR)
install.packages(circlepackeR)
install_github("jeromefroe/circlepackeR")
install.packages('packcircles')
install.packages('circlepackeR')
# Circlepacker package
library(circlepackeR)
# Circlepacker package
require(circlepackeR)
# Let's use the 'flare dataset' (stored in the ggraph library)
library(ggraph)
install.packages('ggraph')
# Let's use the 'flare dataset' (stored in the ggraph library)
library(ggraph)
data_edge <- flare$edges
require(ggraph)
data_edge <- flare$edges
# Let's use the 'flare dataset' (stored in the ggraph library)
library(ggraph)
data <- data.frame(
root=rep("root", 15),
group=c(rep("group A",5), rep("group B",5), rep("group C",5)),
subgroup= rep(letters[1:5], each=3),
subsubgroup=rep(letters[1:3], 5),
value=sample(seq(1:15), 15)
)
data
# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
library(data.tree)
install.packages('data tree')
library(ggraph)
data$pathString <- paste("world", data$group, data$subgroup, data$subsubgroup, sep = "/")
population <- as.Node(data)
population
# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
library(data.tree)
# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
require(data.tree)
install.packages('data.tree')
# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
require(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, data$subsubgroup, sep = "/")
population <- as.Node(data)
population
data
# You can custom the minimum and maximum value of the color range.
p <- circlepackeR(population, size = "value", color_min = "hsl(56,80%,80%)", color_max = "hsl(341,30%,40%)")
# Circlepacker package
require(circlepackeR)
install.packages('circlepackeR')
# Circlepacker package
require(circlepackeR)
# You can custom the minimum and maximum value of the color range.
p <- circlepackeR(population, size = "value", color_min = "hsl(56,80%,80%)", color_max = "hsl(341,30%,40%)")
install.packages('circlepackeR')
setRepositories()
setRepositories(ind = c(1:6, 8))
setRepositories()
setRepositories(ind = c(1:6, 8))
available.packages()
install.packages('circlepackeR')
ap <- available.packages()
View(ap)
install.packages('devtools')
install_github("jeromefroe/circlepackeR")
# Circlepacker package
require(devtools)
install_github("jeromefroe/circlepackeR")
# You can custom the minimum and maximum value of the color range.
p <- circlepackeR(population, size = "value", color_min = "hsl(56,80%,80%)", color_max = "hsl(341,30%,40%)")
require(circlepackeR)
# You can custom the minimum and maximum value of the color range.
p <- circlepackeR(population, size = "value", color_min = "hsl(56,80%,80%)", color_max = "hsl(341,30%,40%)")
# Make the plot
circlepackeR(population, size = "value")
data
sonel0.01
dim(colnames(df)[2:250])
colnames(df)[2:250]
distru=colnames(df)[2:250]
data
2!=3
del_zeros = function(x){
n=length(x)
r=c()
for (i in 1:n) {
if (x[i]!= 0) {
r=c(r,x[i])
}
}
return(r)
}
sonel0.01
l=c()
for (i in 1:ncol(sonel0.01)) {
l=c(l,length(del_zeros(sonel0.01[,i])))
}
l
length(l)
distru[c(1,2,3)]
distru[c(1,3,2)]
c(distru[c(1,3,2)],distru[c(3,1)])
m=c()
for (i in 1:ncol(sonel0.01)) {
m=c(m,distru[del_zeros(sonel0.01[,i])])
}
length(m)
data <- data.frame(
root=rep("root", 15),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m,
)
data <- data.frame(
root=rep("root", 249),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m,
)
data <- data.frame(
root=rep("root", 249),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m
)
head(data)
require(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, sep = "/")
population <- as.Node(data)
population
circlepackeR(population)
data
data <- data.frame(
root=rep("root", 249),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m,
value=rep(1,249)
)
head(data)
require(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, sep = "/")
population <- as.Node(data)
circlepackeR(population,size = "value")
# save the widget
library(htmlwidgets)
getwd()
saveWidget(p, file=paste0( getwd(), "/HtmlWidget/circular_packing_circlepackeR2.html"))
saveWidget(p, file=paste0( getwd(), "/circular_packing_circlepackeR2.html"))
# Make the plot
p=circlepackeR(population,size = "value")
saveWidget(p, file=paste0( getwd(), "/circular_packing_circlepackeR2.html"))
data <- data.frame(
root=rep("root", 15),
group=c(rep("group A",5), rep("group B",5), rep("group C",5)),
subgroup= rep(letters[1:5], each=3),
subsubgroup=rep(letters[1:3], 5),
value=sample(seq(1:15), 15)
)
require(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, data$subsubgroup, sep = "/")
population <- as.Node(data)
# Make the plot
circlepackeR(population, size = "value")
data
data <- data.frame(
root=rep("root", 249),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m,
value=c(rep(l[1],l[1]),rep(l[2],l[2]),rep(l[3],l[3]),rep(l[4],l[4]),rep(l[5],l[5]),
rep(l[6],l[6]),rep(l[7],l[7]),rep(l[8],l[8]),rep(l[9],l[9]),rep(l[10],l[10]),
rep(l[12],l[12]),rep(l[13],l[13]),rep(l[14],l[14]),rep(l[15],l[15]))
)
length(l)
data <- data.frame(
root=rep("root", 249),
group=c(rep("group A",l[1]), rep("group B",l[2]), rep("group C",l[3]), rep("group D",l[4]),
rep("group E",l[5]), rep("group F",l[6]), rep("group G",l[7]), rep("group H",l[8]),
rep("group I",l[9]), rep("group J",l[10]),rep("group K",l[11]),rep("group L",l[12]),
rep("group M",l[13]),rep("group N",l[14]),rep("group O",l[15])),
subgroup= m,
value=c(rep(l[1],l[1]),rep(l[2],l[2]),rep(l[3],l[3]),rep(l[4],l[4]),rep(l[5],l[5]),
rep(l[6],l[6]),rep(l[7],l[7]),rep(l[8],l[8]),rep(l[9],l[9]),rep(l[10],l[10]),
rep(l[11],l[11]),rep(l[12],l[12]),rep(l[13],l[13]),rep(l[14],l[14]),rep(l[15],l[15]))
)
# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
require(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, sep = "/")
population <- as.Node(data)
# Make the plot
p=circlepackeR(population,size = "value")
p
